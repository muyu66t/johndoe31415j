/*
 *   This file was AUTO-GENERATED by pypgmopts.
 *
 *   https://github.com/johndoe31415/pypgmopts
 *
 *   Do not edit it by hand, your changes will be overwritten.
 *
 *   Generated at: 2020-01-06 10:38:00
 */

#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include <stdarg.h>
#include <string.h>
#include "argparse.h"

static enum argparse_option_t last_parsed_option;
static char last_error_message[256];
static const char *option_texts[] = {
	[ARG_MODE] = "-m / --mode",
	[ARG_PRIME_TYPE] = "-p / --prime-type",
	[ARG_THREAD_CNT] = "-t / --thread-cnt",
	[ARG_BIT_LENGTH] = "-b / --bit-length",
	[ARG_NUM_PRIMES] = "-n / --num-primes",
};

enum argparse_option_internal_t {
	ARG_MODE_SHORT = 'm',
	ARG_PRIME_TYPE_SHORT = 'p',
	ARG_THREAD_CNT_SHORT = 't',
	ARG_BIT_LENGTH_SHORT = 'b',
	ARG_NUM_PRIMES_SHORT = 'n',
	ARG_MODE_LONG = 1000,
	ARG_PRIME_TYPE_LONG = 1001,
	ARG_THREAD_CNT_LONG = 1002,
	ARG_BIT_LENGTH_LONG = 1003,
	ARG_NUM_PRIMES_LONG = 1004,
};

static void errmsg_callback(const char *errmsg, ...) {
	va_list ap;
	va_start(ap, errmsg);
	vsnprintf(last_error_message, sizeof(last_error_message), errmsg, ap);
	va_end(ap);
}

static void errmsg_option_callback(enum argparse_option_t error_option, const char *errmsg, ...) {
	last_parsed_option = error_option;

	va_list ap;
	va_start(ap, errmsg);
	vsnprintf(last_error_message, sizeof(last_error_message), errmsg, ap);
	va_end(ap);
}

bool argparse_parse(int argc, char **argv, argparse_callback_t argument_callback, argparse_plausibilization_callback_t plausibilization_callback) {
	last_parsed_option = ARGPARSE_NO_OPTION;
	const char *short_options = "m:p:t:b:n:";
	struct option long_options[] = {
		{ "mode",                             required_argument, 0, ARG_MODE_LONG },
		{ "prime-type",                       required_argument, 0, ARG_PRIME_TYPE_LONG },
		{ "thread-cnt",                       required_argument, 0, ARG_THREAD_CNT_LONG },
		{ "bit-length",                       required_argument, 0, ARG_BIT_LENGTH_LONG },
		{ "num-primes",                       required_argument, 0, ARG_NUM_PRIMES_LONG },
		{ 0 }
	};

	while (true) {
		int optval = getopt_long(argc, argv, short_options, long_options, NULL);
		if (optval == -1) {
			break;
		}
		last_error_message[0] = 0;
		enum argparse_option_internal_t arg = (enum argparse_option_internal_t)optval;
		switch (arg) {
			case ARG_MODE_SHORT:
			case ARG_MODE_LONG:
				last_parsed_option = ARG_MODE;
				if (!argument_callback(ARG_MODE, optarg, errmsg_callback)) {
					return false;
				}
				break;

			case ARG_PRIME_TYPE_SHORT:
			case ARG_PRIME_TYPE_LONG:
				last_parsed_option = ARG_PRIME_TYPE;
				if (!argument_callback(ARG_PRIME_TYPE, optarg, errmsg_callback)) {
					return false;
				}
				break;

			case ARG_THREAD_CNT_SHORT:
			case ARG_THREAD_CNT_LONG:
				last_parsed_option = ARG_THREAD_CNT;
				if (!argument_callback(ARG_THREAD_CNT, optarg, errmsg_callback)) {
					return false;
				}
				break;

			case ARG_BIT_LENGTH_SHORT:
			case ARG_BIT_LENGTH_LONG:
				last_parsed_option = ARG_BIT_LENGTH;
				if (!argument_callback(ARG_BIT_LENGTH, optarg, errmsg_callback)) {
					return false;
				}
				break;

			case ARG_NUM_PRIMES_SHORT:
			case ARG_NUM_PRIMES_LONG:
				last_parsed_option = ARG_NUM_PRIMES;
				if (!argument_callback(ARG_NUM_PRIMES, optarg, errmsg_callback)) {
					return false;
				}
				break;

			default:
				last_parsed_option = ARGPARSE_NO_OPTION;
				errmsg_callback("unrecognized option supplied");
				return false;
		}
	}

	const int positional_argument_cnt = argc - optind;
	last_parsed_option = ARGPARSE_POSITIONAL_ARG;
	if (positional_argument_cnt != 0) {
		errmsg_callback("expected exactly 0 positional arguments, but %d given.", positional_argument_cnt);
		return false;
	}

	if (plausibilization_callback) {
		if (!plausibilization_callback(errmsg_option_callback)) {
			return false;
		}
	}
	return true;
}

void argparse_show_syntax(void) {
	fprintf(stderr, "usage: primegen [-m {random,crt}] [-p {2msb,3msb}] [-t number] [-b bits]\n");
	fprintf(stderr, "                [-n cnt]\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "Multithreaded prime generation\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "optional arguments:\n");
	fprintf(stderr, "  -m {random,crt}, --mode {random,crt}\n");
	fprintf(stderr, "                        Mode in which to try to generate primes. Can be one of\n");
	fprintf(stderr, "                        random, crt, defaults to random.\n");
	fprintf(stderr, "  -p {2msb,3msb}, --prime-type {2msb,3msb}\n");
	fprintf(stderr, "                        Types of primes to generate. Either the top 2 most\n");
	fprintf(stderr, "                        significant bits can be set or the top 3 MSB. Can\n");
	fprintf(stderr, "                        therefore be one of 2msb, 3msb, defaults to 2msb.\n");
	fprintf(stderr, "  -t number, --thread-cnt number\n");
	fprintf(stderr, "                        Number of threads to use. Defaults to 8.\n");
	fprintf(stderr, "  -b bits, --bit-length bits\n");
	fprintf(stderr, "                        Number of bits that generated primes will have.\n");
	fprintf(stderr, "                        Defaults to 2048. May be imprecise in case of CRT-\n");
	fprintf(stderr, "                        generated primes.\n");
	fprintf(stderr, "  -n cnt, --num-primes cnt\n");
	fprintf(stderr, "                        Number of primes that are generated by primegen.\n");
	fprintf(stderr, "                        Defaults to 10.\n");
}

void argparse_parse_or_quit(int argc, char **argv, argparse_callback_t argument_callback, argparse_plausibilization_callback_t plausibilization_callback) {
	if (!argparse_parse(argc, argv, argument_callback, plausibilization_callback)) {
		if (last_parsed_option > ARGPARSE_POSITIONAL_ARG) {
			if (last_error_message[0]) {
				fprintf(stderr, "primegen: error parsing argument %s -- %s\n", option_texts[last_parsed_option], last_error_message);
			} else {
				fprintf(stderr, "primegen: error parsing argument %s -- no details available\n", option_texts[last_parsed_option]);
			}
		} else if (last_parsed_option == ARGPARSE_POSITIONAL_ARG) {
			fprintf(stderr, "primegen: error parsing optional arguments -- %s\n", last_error_message);
		}
		argparse_show_syntax();
		exit(EXIT_FAILURE);
	}
}

#ifdef __ARGPARSE_MAIN__
/*   gcc -D __ARGPARSE_MAIN__ -O2 -Wall -o argparse argparse.c
*/

static const char *option_enum_to_str(enum argparse_option_t option) {
	switch (option) {
		case ARG_MODE: return "ARG_MODE";
		case ARG_PRIME_TYPE: return "ARG_PRIME_TYPE";
		case ARG_THREAD_CNT: return "ARG_THREAD_CNT";
		case ARG_BIT_LENGTH: return "ARG_BIT_LENGTH";
		case ARG_NUM_PRIMES: return "ARG_NUM_PRIMES";
	}
	return "UNKNOWN";
}

bool arg_print_callback(enum argparse_option_t option, const char *value, argparse_errmsg_callback_t errmsg_callback) {
	fprintf(stderr, "%s = \"%s\"\n", option_enum_to_str(option), value);
	return true;
}

int main(int argc, char **argv) {
	argparse_parse_or_quit(argc, argv, arg_print_callback, NULL);
	return 0;
}
#endif
